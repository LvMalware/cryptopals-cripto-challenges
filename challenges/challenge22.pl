use utf8;
use strict;
use warnings;
require "./challenge21.pl";

my $timestamp = time;

sub get_rng
{
    #I dont want to wait ... so let's just simulate the passage of time :p
    #now, a random number of seconds just passed
    my $seed = ($timestamp += int(40 + rand 1000));
    MT19937::seed_mt ($seed);
    #and a random number of seconds passed again
    $timestamp += int(40 + rand 1000);
    #return the seed just to verification purposes
    ($seed, MT19937::extract_number())
}

sub find_seed
{
    #my approach may be a little silly, but I hope it works (hehe)
    my $first_rnd = shift;
    #depending on a number of factors (like the clock speed, etc.) we may have
    #a slightly problem on simulating the time passage this way. So, let's also
    #consider the possibility of our last saved timestamp be the seed itself.
    my $possible_seed  = $timestamp + 1;
    #now we performe a kind of brute force process on the seed, decreasing the
    #possible seed by 1 until we find that the first random number generated by
    #our seed matches the first random number generated by the original seed
    MT19937::seed_mt ($possible_seed);
    while ($possible_seed)
    {
        if (MT19937::extract_number() == $first_rnd)
        {
            return $possible_seed;
        }
        MT19937::seed_mt (-- $possible_seed);
    }
    die "Couldn't find the seed."
}

sub test
{
    my ($true_seed, $random) = get_rng;
    my $maybe_seed = find_seed $random;
    print "The real seed was: $true_seed\n";
    print "We found the seed: $maybe_seed\n";
    if ($maybe_seed == $true_seed)
    {
        print "It worked!\n";
    }
    else
    {
        print "I'm a failure :(\n";
    }
}

test unless caller;